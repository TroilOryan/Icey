// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `to_ref`, `to_ref`, `to_ref`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `LyricLine`, `LyricWord`, `TTMLLyric`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`, `default`, `default`, `is_empty`, `is_empty`, `to_line`, `to_owned`, `to_owned`

class LyricLineOwned {
  final List<LyricWordOwned> words;
  final String translatedLyric;
  final String romanLyric;
  final bool isBg;
  final bool isDuet;
  final BigInt startTime;
  final BigInt endTime;

  const LyricLineOwned({
    required this.words,
    required this.translatedLyric,
    required this.romanLyric,
    required this.isBg,
    required this.isDuet,
    required this.startTime,
    required this.endTime,
  });

  static Future<LyricLineOwned> default_() =>
      RustLib.instance.api.crateApiLyricParserLyricLineOwnedDefault();

  Future<bool> isEmpty() =>
      RustLib.instance.api.crateApiLyricParserLyricLineOwnedIsEmpty(that: this);

  Future<String> toLine() =>
      RustLib.instance.api.crateApiLyricParserLyricLineOwnedToLine(that: this);

  @override
  int get hashCode =>
      words.hashCode ^
      translatedLyric.hashCode ^
      romanLyric.hashCode ^
      isBg.hashCode ^
      isDuet.hashCode ^
      startTime.hashCode ^
      endTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LyricLineOwned &&
          runtimeType == other.runtimeType &&
          words == other.words &&
          translatedLyric == other.translatedLyric &&
          romanLyric == other.romanLyric &&
          isBg == other.isBg &&
          isDuet == other.isDuet &&
          startTime == other.startTime &&
          endTime == other.endTime;
}

class LyricWordOwned {
  final BigInt startTime;
  final BigInt endTime;
  final String word;
  final String romanWord;

  const LyricWordOwned({
    required this.startTime,
    required this.endTime,
    required this.word,
    required this.romanWord,
  });

  static Future<LyricWordOwned> default_() =>
      RustLib.instance.api.crateApiLyricParserLyricWordOwnedDefault();

  Future<bool> isEmpty() =>
      RustLib.instance.api.crateApiLyricParserLyricWordOwnedIsEmpty(that: this);

  @override
  int get hashCode =>
      startTime.hashCode ^
      endTime.hashCode ^
      word.hashCode ^
      romanWord.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LyricWordOwned &&
          runtimeType == other.runtimeType &&
          startTime == other.startTime &&
          endTime == other.endTime &&
          word == other.word &&
          romanWord == other.romanWord;
}

class TTMLLyricOwned {
  final List<LyricLineOwned> lines;
  final List<(String, List<String>)> metadata;

  const TTMLLyricOwned({required this.lines, required this.metadata});

  static Future<TTMLLyricOwned> default_() =>
      RustLib.instance.api.crateApiLyricParserTtmlLyricOwnedDefault();

  @override
  int get hashCode => lines.hashCode ^ metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TTMLLyricOwned &&
          runtimeType == other.runtimeType &&
          lines == other.lines &&
          metadata == other.metadata;
}
